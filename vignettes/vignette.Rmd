---
title: "vignette"
author: 
- name: Jiefei Wang
  affiliation: Roswell Park Comprehensive Cancer Center, Buffalo, NY
date: "`r Sys.Date()`"
output:
    BiocStyle::html_document:
        toc: true
        toc_float: true
vignette: >
  %\VignetteIndexEntry{vignette}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
package: Travel
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
options(scipen=999)
library(Travel)
library(inline)
Travel:::deploy_filesystem()
Travel:::set_verbose(FALSE)
```

# Introduction
## ALTREP
ALTREP is a relatively new feature that has been released since R3.5. It stands for alternative representation of R's basic object(vector object). The main motivation is to reduce the memory load when creating some special vector. Consider the example
```{r}
x <- 1:(1024*1024*1024*1024)
length(x)
typeof(x)
```
You might think the above crazy code will exhaust all the memory in your machine and burn your computer into ash. However, if you are using any version of R that is equal or newer than 3.5, the code works like a charm. You can access the data of `x` as usual
```{r}
head(x)
```
You might have a guess on what has happened here. The data of the vector `x` clearly has a lot of redundance. Since it is an arithmetic sequence, you only need to know the first item and common difference to know every values in `x`. As long as you do not need the entire data at once, it would not consumes all of your memory. A minimum ALTREP object can be made by defining a length function and an element retrieving function at C level, the function prototypes are
```{}
R_xlen_t length(SEXP x);
double real_elt(SEXP x, R_xlen_t i);
```
We wouldn't go into details of the ALTREP but you can see how to use the above two functions to get the length and values from the vector `x`. If you are interested in making your own ALTREP, here are two great documents from the ancient time
1.[ALTREP and Other Things](https://www.r-project.org/dsc/2017/slides/dsc2017.pdf): A review of the structure of ALTREP
2.[ALTREP and C++](https://purrple.cat/blog/2018/10/14/altrep-and-cpp/): A tutorial of ALTREP with  examples. It helps me a lot when I first saw the idea of ALTREP
## Challenge with ALTREP
Although the idea of the ALTREP sounds exciting as it greatly extends the flexibility of R's vector, it also breaks the assumption that all R's vectors have a pointer associated with them. While today's R developers might be aware of it, there has been tons of packages developed before ALTREP and their work depends on this assumption. Before R3.5, It is very common to loop over the data of R's vector at C level like 
```
double my_sum(SEXP x){
  double* ptr = (double*)DATAPTR(x);
  double total = 0;
  for(int i = 0; i < XLENGTH(x); ++i){
    total = total + ptr[i];
  }
  return total;
}
```
The above code works for a regular R vector since its data has been in the memory. However, for an ALTREP object, as it might not have a pointer, it only has two options when `DATAPTR` is called:
1. Allocating the data in memory and return the pointer that is requested.
2. Call `Rf_error` to throw an error message.
While the first one seems to be a good choice, it is actually not always feasible in practice for the object might be larger than the available memory(As the crazy vector example we saw previously). The second choice can be used if a pointer cannot be given, but it prevents the ALTREP object from being used by many old but useful packages. Also, it might causes memory leaking for the objects allocated in heap may not have a chance to release themselves. For an arithmetic sequence in the first example, it actually adopt both strategies: It will allocate the memory for a short sequence, but throw an error for a long sequence. For example
```{r}
## Short sequence
x1 <- 1:10
x1[1] <- 10 
head(x)

## long sequence 
x2 <- 1:(1024*1024*1024*1024)
tryCatch({x2[1] <- 10 }, error = function(e) message(e))
```
As of R4.1, every attempt to change the R vector will require to access the pointer of the vector. For a short sequence this can be easily solved via the memory allocation. However, for a large sequence, since there would not be enough space for a 8192Gb vector, doing so will end up with an error message. 
Requiring the pointer from an ALTREP object has been a very serious limitation that prevents it from being used in practice to represent a large data. Travel package can help to mitigate the problem.

## Travel package
Travel package is an utility for developers to build ALTREP objects with a virtual pointer. The pointer of the ALTREP object can be accessed via the regular `DATAPTR` function in `Rinternal.h` at C level. The basic workflow of using the package is

![](Making altrep.png)

The pointer is "virtual" in the sense that the data does not exist in the memory before one actually try to access the data. The pointer is made via File mapping, but it wouldn't consume any disk space neither for the file been mapped is also a virtual file. All the request to access the file will be sent to developer's provided callback function. Suppose we have made an ALTREP object with the data reading function `read_data`. Let the pointer of the ALTREP object be `ptr`. Here is what happens behind the scenes when you want to read the `i`th element of the pointer

![](data request.png)

As we see from the flowchart, the data of the pointer `ptr` is made on-demand. The pointer would not exhaust the memory even if it points to an extremely large object. By doing that we solve the main limitation of the ALTREP. The pointer of the ALTREP object can be accessed in a usual way, and the memory consumption is minimum. Take the crazy large vector as the example again, the package provide a wrapper function for turning an old ALTREP object into a new ALTREP object with a virtual pointer. 
```{r}
x <- 1:(1024*1024*1024*1024)
y <- wrap_altrep(x)

x[1:10]
y[1:10]
```
While `x` and `y` looks the same, the pointer of `y` can be accessed as usual
```{r}
## We only compute the sum of the first 10 elements
code <- 
'
  double* ptr = (double*)DATAPTR(x);
  double total = 0;
    for(int i = 0; i < 10; ++i){
    total = total + ptr[i];
    }
  return ScalarReal(total);
'
my_sum <- cxxfunction(signature(x="SEXP"),
                    body=code)

## An error will be given for x
tryCatch(my_sum(x), error = function(e) message(e))
## No error will be given and the sum can be computed
my_sum(y)
```
Furthermore, the data of the vector `y` is multable.
```{r}
y[1] <- 1
my_sum(y)
```
Please note that the wrapper function `wrap_altrep` should be used with caution for it will call R's function in a multithreaded environment. As R is known to be a single thread program, it is not recommended to use the function in practice. `wrap_altrep` should only be called for demonstration purpose. In the next section, we will show you how to formally use the Travel package step by step to create your own ALTREP object.

# Travel tutorial



